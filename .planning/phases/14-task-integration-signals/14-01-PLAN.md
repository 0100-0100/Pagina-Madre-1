---
phase: 14-task-integration-signals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - ___/accounts/models.py
  - ___/accounts/migrations/0007_cedulainfo_retry_count.py
  - ___/accounts/signals.py
  - ___/accounts/tasks.py
  - ___/accounts/apps.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "New user registration creates CedulaInfo with PENDING status"
    - "Background task is queued after registration transaction commits"
    - "Task retries retriable errors (timeout, blocked, captcha_failed) up to 3 times"
    - "Exponential backoff delays: 1min, 5min, 15min between retries"
    - "Permanent statuses (found, not_found, cancelled) do not trigger retry"
  artifacts:
    - path: "___/accounts/models.py"
      provides: "retry_count field on CedulaInfo"
      contains: "retry_count = models.PositiveSmallIntegerField"
    - path: "___/accounts/signals.py"
      provides: "post_save signal handler with transaction.on_commit"
      exports: ["queue_cedula_validation"]
    - path: "___/accounts/tasks.py"
      provides: "validate_cedula task with retry logic"
      exports: ["validate_cedula"]
    - path: "___/accounts/apps.py"
      provides: "Signal registration in ready()"
      contains: "from . import signals"
  key_links:
    - from: "___/accounts/signals.py"
      to: "___/accounts/tasks.py"
      via: "async_task('accounts.tasks.validate_cedula', user_id)"
      pattern: "async_task.*accounts\\.tasks\\.validate_cedula"
    - from: "___/accounts/tasks.py"
      to: "___/accounts/scraper.py"
      via: "scraper.scrape_cedula(user.cedula)"
      pattern: "scraper\\.scrape_cedula"
    - from: "___/accounts/tasks.py"
      to: "django_q.tasks.schedule"
      via: "schedule() for retry with next_run"
      pattern: "schedule\\("
---

<objective>
Wire the Playwright scraper to Django-Q2 via post_save signal on CustomUser.

Purpose: Auto-trigger cedula validation when users register, with exponential backoff retries for transient failures.
Output: Signal handler queues background task that scrapes Registraduria and updates CedulaInfo.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-task-integration-signals/14-CONTEXT.md
@.planning/phases/14-task-integration-signals/14-RESEARCH.md
@___/accounts/models.py
@___/accounts/tasks.py
@___/accounts/scraper.py
@___/accounts/apps.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add retry_count field to CedulaInfo model</name>
  <files>___/accounts/models.py, ___/accounts/migrations/0007_cedulainfo_retry_count.py</files>
  <action>
Add retry_count field to CedulaInfo model in ___/accounts/models.py:

```python
retry_count = models.PositiveSmallIntegerField(
    default=0,
    verbose_name='Intentos',
)
```

Add this field after the `raw_response` field in the Metadata fields section. Use Spanish verbose_name consistent with existing fields.

Then generate migration:
```bash
cd ___
python manage.py makemigrations accounts --name cedulainfo_retry_count
python manage.py migrate
```
  </action>
  <verify>
```bash
cd ___
python manage.py check
python manage.py showmigrations accounts | grep 0007
```
Migration 0007_cedulainfo_retry_count should appear as applied.
  </verify>
  <done>CedulaInfo model has retry_count field with default=0 and migration applied.</done>
</task>

<task type="auto">
  <name>Task 2: Create signal handler and validate_cedula task</name>
  <files>___/accounts/signals.py, ___/accounts/tasks.py</files>
  <action>
**Create ___/accounts/signals.py** with post_save handler:

```python
"""
Signals for the accounts app.

Signal handlers are registered in AccountsConfig.ready() via import.
"""
import logging
from functools import partial

from django.db import transaction
from django.db.models.signals import post_save
from django.dispatch import receiver
from django_q.tasks import async_task

from .models import CedulaInfo, CustomUser


logger = logging.getLogger('django-q')


@receiver(post_save, sender=CustomUser, dispatch_uid='queue_cedula_validation')
def queue_cedula_validation(sender, instance, created, raw, **kwargs):
    """
    Queue cedula validation task when new user is created.

    Uses transaction.on_commit() to ensure task is queued only after
    the user registration transaction successfully commits.

    Args:
        sender: CustomUser model class
        instance: The saved CustomUser instance
        created: True if new user, False if update
        raw: True if loading fixtures
    """
    if not created:
        return  # Only trigger on new user creation

    if raw:
        return  # Skip when loading fixtures

    # Create CedulaInfo record with PENDING status
    # This happens inside the transaction
    CedulaInfo.objects.create(
        user=instance,
        status=CedulaInfo.Status.PENDING,
        retry_count=0
    )

    logger.info("CedulaInfo created for user %s, queueing validation task",
                instance.cedula)

    # Queue async task AFTER transaction commits
    # Using partial to pass user_id
    transaction.on_commit(
        partial(_queue_validation_task, instance.id),
        using='default'
    )


def _queue_validation_task(user_id):
    """
    Helper function to queue the validation task.

    Called by on_commit after transaction commits successfully.
    """
    task_id = async_task(
        'accounts.tasks.validate_cedula',
        user_id,
        task_name=f'validate_cedula_{user_id}'
    )
    logger.info("Queued validate_cedula task %s for user_id=%s", task_id, user_id)
```

**Update ___/accounts/tasks.py** - Replace contents with full task implementation:

```python
"""
Background tasks for the accounts app.

Tasks are executed by Django-Q2 qcluster worker process.
Run worker: python manage.py qcluster
"""
import logging
from datetime import timedelta

from django.utils import timezone
from django_q.tasks import schedule

from .models import CedulaInfo, CustomUser
from .scraper import RegistraduriaScraper


logger = logging.getLogger('django-q')

# Backoff delays in seconds: 1min, 5min, 15min
RETRY_DELAYS = [60, 300, 900]
MAX_ATTEMPTS = 3

# Status codes that should NOT trigger retry (permanent results)
PERMANENT_STATUSES = {'found', 'not_found', 'cancelled'}


def echo_test(message):
    """Simple test task to verify Django-Q2 is working.

    Usage in Django shell:
        from django_q.tasks import async_task
        task_id = async_task('accounts.tasks.echo_test', 'Hello Django-Q2!')
    """
    logger.info("Echo task executed: %s", message)
    return f"Echo: {message}"


def validate_cedula(user_id, attempt=1):
    """
    Validate cedula via Registraduria scraper.

    Called by post_save signal on CustomUser creation.
    Implements exponential backoff retry for transient errors.

    Args:
        user_id: CustomUser.id to validate
        attempt: Current attempt number (1-based, max 3)
    """
    try:
        user = CustomUser.objects.get(id=user_id)
        cedula_info = user.cedula_info
    except CustomUser.DoesNotExist:
        logger.error("validate_cedula: User %s not found", user_id)
        return
    except CedulaInfo.DoesNotExist:
        logger.error("validate_cedula: CedulaInfo not found for user %s", user_id)
        return

    # Update status to PROCESSING (browser actively running)
    cedula_info.status = CedulaInfo.Status.PROCESSING
    cedula_info.save(update_fields=['status'])

    logger.info("validate_cedula: User %s (cedula=%s), attempt %d/%d",
                user_id, user.cedula, attempt, MAX_ATTEMPTS)

    # Run scraper
    scraper = RegistraduriaScraper()
    result = scraper.scrape_cedula(user.cedula)

    # Process result based on status
    status = result.get('status')

    if status == 'found':
        _handle_found(cedula_info, result)
    elif status == 'not_found':
        _handle_not_found(cedula_info)
    elif status == 'cancelled':
        _handle_cancelled(cedula_info, result)
    else:
        # Retriable error: timeout, network_error, captcha_failed, parse_error, blocked
        _handle_retriable_error(cedula_info, result, user_id, attempt)


def _handle_found(cedula_info, result):
    """Update CedulaInfo with voting location data."""
    cedula_info.status = CedulaInfo.Status.ACTIVE
    cedula_info.departamento = result.get('departamento') or ''
    cedula_info.municipio = result.get('municipio') or ''
    cedula_info.puesto = result.get('puesto') or ''
    cedula_info.direccion = result.get('direccion') or ''
    cedula_info.mesa = result.get('mesa') or ''
    cedula_info.fetched_at = timezone.now()
    cedula_info.error_message = ''
    cedula_info.save()
    logger.info("validate_cedula: FOUND - %s", cedula_info.user.cedula)


def _handle_not_found(cedula_info):
    """Update CedulaInfo as not found in census."""
    cedula_info.status = CedulaInfo.Status.NOT_FOUND
    cedula_info.fetched_at = timezone.now()
    cedula_info.error_message = ''
    cedula_info.save()
    logger.info("validate_cedula: NOT_FOUND - %s", cedula_info.user.cedula)


def _handle_cancelled(cedula_info, result):
    """Update CedulaInfo with cancelled cedula data."""
    # Determine if deceased or other cancellation
    novedad = result.get('novedad') or ''
    if 'FALLECIDO' in novedad.upper() or 'MUERTE' in novedad.upper():
        cedula_info.status = CedulaInfo.Status.CANCELLED_DECEASED
    else:
        cedula_info.status = CedulaInfo.Status.CANCELLED_OTHER

    cedula_info.novedad = novedad
    cedula_info.resolucion = result.get('resolucion') or ''
    cedula_info.fecha_novedad = result.get('fecha_novedad') or ''
    cedula_info.fetched_at = timezone.now()
    cedula_info.error_message = ''
    cedula_info.save()
    logger.info("validate_cedula: CANCELLED - %s", cedula_info.user.cedula)


def _handle_retriable_error(cedula_info, result, user_id, attempt):
    """Handle retriable error: schedule retry or mark as final error."""
    error_status = result.get('status', 'error')
    error_msg = result.get('error', 'Unknown error')

    if attempt < MAX_ATTEMPTS:
        # Schedule retry with exponential backoff
        delay_seconds = RETRY_DELAYS[attempt - 1]  # 0-indexed: [60, 300, 900]
        next_run = timezone.now() + timedelta(seconds=delay_seconds)

        # Update status and retry count
        cedula_info.retry_count = attempt
        cedula_info.error_message = f"Attempt {attempt}: {error_status} - {error_msg}"
        cedula_info.save(update_fields=['retry_count', 'error_message'])

        logger.warning(
            "validate_cedula: %s on attempt %d, scheduling retry in %ds for user %s",
            error_status, attempt, delay_seconds, user_id
        )

        # Schedule delayed retry using Django-Q2 schedule()
        schedule(
            'accounts.tasks.validate_cedula',
            user_id,
            attempt + 1,
            schedule_type='O',  # Once (one-time execution)
            next_run=next_run,
            name=f'validate_cedula_retry_{user_id}_{attempt + 1}'
        )
    else:
        # Max attempts exhausted - set final error status
        _mark_as_error(cedula_info, error_status, error_msg, result.get('raw_html'))


def _mark_as_error(cedula_info, error_status, error_msg, raw_html=None):
    """Mark CedulaInfo as ERROR after all retries exhausted."""
    # Map scraper status to CedulaInfo.Status
    if error_status == 'timeout':
        cedula_info.status = CedulaInfo.Status.TIMEOUT
    elif error_status == 'blocked':
        cedula_info.status = CedulaInfo.Status.BLOCKED
    else:
        cedula_info.status = CedulaInfo.Status.ERROR

    cedula_info.retry_count = MAX_ATTEMPTS
    cedula_info.error_message = f"After {MAX_ATTEMPTS} attempts: {error_msg}"
    cedula_info.fetched_at = timezone.now()
    if raw_html:
        cedula_info.raw_response = raw_html
    cedula_info.save()
    logger.error("validate_cedula: ERROR after max attempts - %s",
                 cedula_info.user.cedula)
```
  </action>
  <verify>
```bash
cd ___
python -c "from accounts.signals import queue_cedula_validation; print('signals.py: OK')"
python -c "from accounts.tasks import validate_cedula, RETRY_DELAYS, MAX_ATTEMPTS; print(f'tasks.py: OK (delays={RETRY_DELAYS}, max={MAX_ATTEMPTS})')"
```
Both imports should succeed.
  </verify>
  <done>signals.py exists with post_save handler using transaction.on_commit(). tasks.py has validate_cedula with exponential backoff retry logic.</done>
</task>

<task type="auto">
  <name>Task 3: Register signals in AppConfig and verify integration</name>
  <files>___/accounts/apps.py</files>
  <action>
**Update ___/accounts/apps.py** to import signals in ready():

```python
from django.apps import AppConfig


class AccountsConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'accounts'

    def ready(self):
        # Import signals to register handlers
        from . import signals  # noqa: F401
```

**Verify end-to-end integration:**

1. Run Django system check:
```bash
cd ___
python manage.py check
```

2. Test signal fires by creating user in shell (without qcluster running):
```bash
cd ___
python manage.py shell -c "
from accounts.models import CustomUser, CedulaInfo

# Create test user
user = CustomUser.objects.create_user(
    username='signaltest123',
    cedula='1234567890',
    nombre_completo='Signal Test User',
    phone='3001234567',
    password='testpass123',
    data_policy_accepted=True
)
print(f'Created user: {user.cedula}')

# Verify CedulaInfo was created with PENDING status
ci = CedulaInfo.objects.get(user=user)
print(f'CedulaInfo status: {ci.status}')
print(f'CedulaInfo retry_count: {ci.retry_count}')

# Check if task was queued (in OrmQ table)
from django_q.models import OrmQ
queued = OrmQ.objects.filter(name__contains='validate_cedula').exists()
print(f'Task queued: {queued}')

# Cleanup
user.delete()
print('Cleanup: test user deleted')
"
```

Expected output:
- CedulaInfo status: PENDING
- CedulaInfo retry_count: 0
- Task queued: True
  </action>
  <verify>
```bash
cd ___
python manage.py check
```
No errors. The manual shell test in the action confirms signal fires and CedulaInfo is created.
  </verify>
  <done>Signal handler registered in AccountsConfig.ready(). New user creation triggers CedulaInfo creation with PENDING status and queues validate_cedula task.</done>
</task>

</tasks>

<verification>
All Phase 14 requirements verified:

1. **TRIG-01** - post_save signal on CustomUser queues background task
   - Check: `grep -r "post_save.*CustomUser" ___/accounts/signals.py`

2. **TRIG-02** - transaction.on_commit() prevents race condition
   - Check: `grep "transaction.on_commit" ___/accounts/signals.py`

3. **TRIG-03** - Exponential backoff retry (max 3 attempts)
   - Check: `grep "RETRY_DELAYS.*60.*300.*900" ___/accounts/tasks.py`
   - Check: `grep "MAX_ATTEMPTS = 3" ___/accounts/tasks.py`
</verification>

<success_criteria>
- [ ] CedulaInfo model has retry_count field (migration 0007 applied)
- [ ] signals.py exists with queue_cedula_validation using transaction.on_commit
- [ ] tasks.py has validate_cedula with 3-attempt retry and 1/5/15 min backoff
- [ ] apps.py imports signals in ready()
- [ ] `python manage.py check` passes
- [ ] Creating test user creates CedulaInfo with PENDING status
- [ ] Creating test user queues task in OrmQ table
</success_criteria>

<output>
After completion, create `.planning/phases/14-task-integration-signals/14-01-SUMMARY.md`
</output>
