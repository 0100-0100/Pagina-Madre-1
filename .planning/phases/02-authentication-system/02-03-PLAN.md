---
phase: 02-authentication-system
plan: 03
type: execute
wave: 3
depends_on: [02-02]
files_modified:
  - ___/middleware.py
  - ___/___/settings.py
autonomous: true

must_haves:
  truths:
    - "Unauthenticated requests to any URL (except /login/, /register/, /admin/) redirect to /login/"
    - "Authenticated users can access all URLs normally"
    - "Login and register pages remain accessible without authentication"
    - "Admin login remains functional (admin has own auth)"
    - "Redirect includes ?next= parameter for post-login navigation"
  artifacts:
    - path: "___/middleware.py"
      provides: "LoginRequiredMiddleware enforcing global authentication"
      exports: ["LoginRequiredMiddleware"]
      min_lines: 25
    - path: "___/___/settings.py"
      contains: "middleware.LoginRequiredMiddleware"
  key_links:
    - from: "___/middleware.py"
      to: "django.conf.settings.LOGIN_URL"
      via: "redirect to LOGIN_URL"
      pattern: "settings\\.LOGIN_URL"
    - from: "___/___/settings.py"
      to: "___/middleware.py"
      via: "MIDDLEWARE list includes LoginRequiredMiddleware"
      pattern: "['\"]middleware\\.LoginRequiredMiddleware['\"]"
---

<objective>
Implement global login-required middleware to protect all routes except authentication pages

Purpose: Enforce authentication across the entire site by redirecting unauthenticated users to login page. Exempts login, register, and admin URLs to prevent redirect loops and preserve admin functionality.

Output:
- LoginRequiredMiddleware class enforcing authentication globally
- MIDDLEWARE configuration in settings.py
- Exemption list for public URLs (login, register, admin)
- ?next= parameter support for post-login redirection
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-authentication-system/02-RESEARCH.md
@.planning/phases/02-authentication-system/02-01-SUMMARY.md
@.planning/phases/02-authentication-system/02-02-SUMMARY.md
@___/___/settings.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create LoginRequiredMiddleware</name>
  <files>___/middleware.py</files>
  <action>
    Create ___/middleware.py (project-level, not in accounts app) with LoginRequiredMiddleware class:

    Imports:
    - from django.shortcuts import redirect
    - from django.conf import settings
    - from django.urls import reverse

    LoginRequiredMiddleware class:
    - __init__(self, get_response): Store get_response
    - __call__(self, request):
      * Check if user is authenticated: if not request.user.is_authenticated
      * Get current path: path = request.path_info
      * Define open_urls list (URLs that don't require auth):
        - settings.LOGIN_URL ('/login/')
        - reverse('register') (dynamically resolve /register/)
        - '/admin/' (admin has own login, must be accessible)
        - '/static/' (static files must be accessible for login/register page styling)
      * Check if path needs authentication: if not any(path.startswith(url) for url in open_urls)
      * If needs auth: return redirect(f'{settings.LOGIN_URL}?next={path}')
      * Otherwise: return self.get_response(request)

    Follow Pattern 4 from RESEARCH.md exactly. This prevents redirect loops by exempting login/register URLs.

    CRITICAL: Place AFTER AuthenticationMiddleware in MIDDLEWARE list (Task 2). If placed before, request.user won't be available yet.

    IMPORTANT: Use startswith() not exact match for URLs like /admin/ to cover /admin/accounts/, /admin/login/, etc.
  </action>
  <verify>
    - File exists: ls ___/middleware.py
    - Check class definition: grep "class LoginRequiredMiddleware" ___/middleware.py
    - Check open_urls includes login, register, admin: grep -E "(LOGIN_URL|register|admin)" ___/middleware.py
    - Check redirect with next parameter: grep "next=" ___/middleware.py
  </verify>
  <done>
    - LoginRequiredMiddleware exists in ___/middleware.py
    - __call__ method checks request.user.is_authenticated
    - open_urls exempts /login/, /register/, /admin/, /static/
    - Unauthenticated requests redirect to LOGIN_URL with ?next= parameter
    - Authenticated requests pass through normally
  </done>
</task>

<task type="auto">
  <name>Task 2: Configure middleware in settings</name>
  <files>___/___/settings.py</files>
  <action>
    Update ___/___/settings.py MIDDLEWARE list:

    Add 'middleware.LoginRequiredMiddleware' to MIDDLEWARE list AFTER 'django.contrib.auth.middleware.AuthenticationMiddleware'.

    The order is critical:
    1. SessionMiddleware must come first (creates request.session)
    2. AuthenticationMiddleware must come before LoginRequiredMiddleware (sets request.user)
    3. LoginRequiredMiddleware comes last in auth chain (checks request.user.is_authenticated)

    Final MIDDLEWARE order should be:
    [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
        'middleware.LoginRequiredMiddleware',  # ADD THIS
    ]

    RESEARCH WARNING: If LoginRequiredMiddleware comes before AuthenticationMiddleware, request.user won't exist yet and middleware will crash. If it comes before SessionMiddleware, session won't be available.
  </action>
  <verify>
    - Check middleware list: grep "middleware.LoginRequiredMiddleware" ___/___/settings.py
    - Verify order: python ___/manage.py shell -c "from django.conf import settings; middleware = settings.MIDDLEWARE; auth_idx = middleware.index('django.contrib.auth.middleware.AuthenticationMiddleware'); login_idx = middleware.index('middleware.LoginRequiredMiddleware'); print('Order OK' if login_idx > auth_idx else 'ERROR: Wrong order')"
  </verify>
  <done>
    - MIDDLEWARE includes 'middleware.LoginRequiredMiddleware'
    - LoginRequiredMiddleware appears AFTER AuthenticationMiddleware
    - Middleware ordering preserves: Security → Session → Auth → LoginRequired
  </done>
</task>

<task type="auto">
  <name>Task 3: Test middleware enforcement</name>
  <files>None (verification only)</files>
  <action>
    Run automated tests to verify middleware behavior:

    1. Test unauthenticated access redirects:
       - Start server in background
       - Curl root URL: curl -I http://127.0.0.1:8000/ (should 302 redirect to /login/)
       - Curl any protected URL: curl -I http://127.0.0.1:8000/protected/ (should 302 to /login/)

    2. Test exempted URLs are accessible:
       - Curl login page: curl -I http://127.0.0.1:8000/login/ (should 200 OK)
       - Curl register page: curl -I http://127.0.0.1:8000/register/ (should 200 OK)
       - Curl admin: curl -I http://127.0.0.1:8000/admin/ (should 302 to /admin/login/ - admin's own redirect)

    3. Test redirect includes next parameter:
       - Curl protected URL: curl -I http://127.0.0.1:8000/some-page/
       - Check Location header contains: /login/?next=/some-page/

    4. Django system check:
       - Run: python ___/manage.py check
       - Should pass with no errors

    Use Python's requests library or curl for testing. Server must be running for these tests.
  </action>
  <verify>
    - Run: python ___/manage.py check
    - Confirm no errors
    - Run: python ___/manage.py shell -c "
    from django.test import Client
    client = Client()

    # Test unauthenticated redirect
    response = client.get('/admin/accounts/')
    if response.status_code == 302 and '/login/' in response.url:
        print('PASS: Unauthenticated request redirected to login')
    else:
        print('FAIL: Unexpected response:', response.status_code, response.url)

    # Test login page accessible
    response = client.get('/login/')
    if response.status_code == 200:
        print('PASS: Login page accessible without auth')
    else:
        print('FAIL: Login page returned:', response.status_code)

    # Test register page accessible
    response = client.get('/register/')
    if response.status_code == 200:
        print('PASS: Register page accessible without auth')
    else:
        print('FAIL: Register page returned:', response.status_code)
    "
  </verify>
  <done>
    - Unauthenticated requests to protected URLs redirect to /login/?next=<path>
    - Login page (/login/) accessible without authentication
    - Register page (/register/) accessible without authentication
    - Admin login (/admin/) accessible (admin handles own auth)
    - Django system check passes without errors
    - No redirect loops observed
  </done>
</task>

</tasks>

<verification>
Comprehensive middleware verification:

1. System check:
   ```bash
   python ___/manage.py check
   ```
   Should pass with no errors

2. Middleware order verification:
   ```bash
   python ___/manage.py shell -c "
   from django.conf import settings
   middleware = settings.MIDDLEWARE
   print('Middleware order:')
   for idx, m in enumerate(middleware):
       print(f'{idx}: {m}')

   auth_idx = middleware.index('django.contrib.auth.middleware.AuthenticationMiddleware')
   login_idx = middleware.index('middleware.LoginRequiredMiddleware')

   if login_idx > auth_idx:
       print('✓ Middleware order correct')
   else:
       print('✗ ERROR: LoginRequiredMiddleware before AuthenticationMiddleware')
   "
   ```

3. Redirect behavior test:
   ```bash
   python ___/manage.py shell -c "
   from django.test import Client

   client = Client()

   # Test 1: Protected URL redirects
   print('Test 1: Protected URL redirect')
   response = client.get('/admin/accounts/', follow=False)
   print(f'Status: {response.status_code}')
   print(f'Location: {response.get('Location', 'N/A')}')
   assert response.status_code == 302
   assert '/login/' in response.get('Location', '')
   print('✓ PASS')

   # Test 2: Login page accessible
   print('\nTest 2: Login page accessible')
   response = client.get('/login/')
   print(f'Status: {response.status_code}')
   assert response.status_code == 200
   print('✓ PASS')

   # Test 3: Register page accessible
   print('\nTest 3: Register page accessible')
   response = client.get('/register/')
   print(f'Status: {response.status_code}')
   assert response.status_code == 200
   print('✓ PASS')

   # Test 4: Next parameter preserved
   print('\nTest 4: Next parameter in redirect')
   response = client.get('/some-protected-path/', follow=False)
   location = response.get('Location', '')
   print(f'Location: {location}')
   assert 'next=' in location
   print('✓ PASS')

   print('\n✓ All middleware tests passed')
   "
   ```

4. No redirect loop check:
   ```bash
   curl -I http://127.0.0.1:8000/login/ 2>&1 | grep "200 OK" && echo "✓ No redirect loop" || echo "✗ Redirect loop detected"
   ```
</verification>

<success_criteria>
Measurable completion state:

1. **Middleware exists**: LoginRequiredMiddleware in ___/middleware.py
2. **Middleware active**: 'middleware.LoginRequiredMiddleware' in settings.MIDDLEWARE
3. **Correct order**: LoginRequiredMiddleware after AuthenticationMiddleware
4. **Redirects work**: Unauthenticated access to protected URLs redirects to /login/
5. **Exemptions work**: /login/, /register/, /admin/ accessible without auth
6. **Next parameter**: Redirects include ?next= for post-login navigation
7. **No loops**: Login and register pages don't redirect to themselves
8. **System check passes**: python manage.py check shows no errors

**Requirements satisfied:**
- AUTH-06: All unauthenticated requests redirect to login page
- AUTH-05 (partial): Logout already configured in 02-02 (LogoutView in urls.py)

**Phase 2 complete:** All AUTH-01 through AUTH-06 and PAGE-01, PAGE-02 requirements satisfied
</success_criteria>

<output>
After completion, create `.planning/phases/02-authentication-system/02-03-SUMMARY.md` following the summary template.

Include in summary:
- Decision: Custom middleware vs third-party package (chose custom for zero dependencies, ~30 lines)
- Pattern established: Global middleware for cross-cutting authentication concerns
- Key insight: Middleware ordering critical (Session → Auth → LoginRequired)
- Security consideration: open_urls uses startswith() to cover sub-paths like /admin/login/
- Why exempting /static/: Login/register pages need CSS/JS without auth
</output>
