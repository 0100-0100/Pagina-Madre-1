---
phase: 11-django-q2-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - requirements.txt
  - ___/___/settings.py
  - ___/accounts/admin.py
  - ___/accounts/tasks.py
autonomous: true

must_haves:
  truths:
    - "Django-Q2 appears in Django admin sidebar"
    - "qcluster process starts without errors"
    - "Echo test task executes and returns result"
    - "No 'database is locked' errors occur"
  artifacts:
    - path: "requirements.txt"
      provides: "Django-Q2 dependency"
      contains: "django-q2"
    - path: "___/___/settings.py"
      provides: "Q_CLUSTER config, WAL mode, logging"
      contains: "Q_CLUSTER"
    - path: "___/accounts/tasks.py"
      provides: "Test task function"
      exports: ["echo_test"]
    - path: "___/accounts/admin.py"
      provides: "Enhanced task admin"
      contains: "FailureAdmin"
  key_links:
    - from: "___/___/settings.py"
      to: "django_q"
      via: "INSTALLED_APPS"
      pattern: "'django_q'"
    - from: "___/___/settings.py"
      to: "SQLite"
      via: "connection_created signal"
      pattern: "PRAGMA journal_mode=WAL"
---

<objective>
Install and configure Django-Q2 task queue with SQLite-safe settings.

Purpose: Establish background task infrastructure for cedula validation scraping in later phases.
Output: Working task queue with admin visibility, WAL mode, and verified task execution.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-django-q2-foundation/11-RESEARCH.md

# Existing files to modify
@___/___/settings.py
@___/accounts/admin.py
@requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Django-Q2 with SQLite-safe configuration</name>
  <files>
    - requirements.txt
    - ___/___/settings.py
    - ___/accounts/tasks.py
  </files>
  <action>
1. Add django-q2==1.9.0 to requirements.txt and install it:
   - Add line: `django-q2==1.9.0`
   - Run: `pip install django-q2==1.9.0`

2. Update ___/___/settings.py:
   a. Add 'django_q' to INSTALLED_APPS (after 'accounts')

   b. Add Q_CLUSTER configuration after INSTALLED_APPS:
      ```python
      # Django-Q2 Configuration
      # ========================
      # Current: SQLite + ORM broker (suitable for <100 users, single worker)
      #
      # UPGRADE PATH for PostgreSQL + Redis (when needed):
      # 1. Install: pip install redis
      # 2. Replace 'orm': 'default' with:
      #    'redis': {
      #        'host': 'localhost',
      #        'port': 6379,
      #        'db': 0,
      #    }
      # 3. Increase 'workers' to match CPU cores
      # 4. Remove WAL mode signal (PostgreSQL handles concurrency natively)
      # 5. Consider separate broker database for high-throughput scenarios

      Q_CLUSTER = {
          'name': 'pagina-madre',
          'workers': 1,  # CRITICAL: SQLite cannot handle concurrent writes
          'timeout': 120,  # 2 minutes max per task (INFRA-04)
          'retry': 180,  # Must exceed timeout - 3 minutes (INFRA-04)
          'queue_limit': 50,
          'save_limit': 250,
          'orm': 'default',  # Use Django's default database as broker (INFRA-01)
          'recycle': 100,
          'ack_failures': True,
          'max_attempts': 3,
          'label': 'Django Q2',
      }
      ```

   c. Add WAL mode signal at the END of settings.py (after all other settings):
      ```python
      # SQLite WAL Mode (INFRA-02)
      # Prevents "database is locked" errors when qcluster and web server run concurrently
      from django.db.backends.signals import connection_created
      from django.dispatch import receiver

      @receiver(connection_created)
      def enable_sqlite_wal(sender, connection, **kwargs):
          """Enable WAL mode for SQLite to prevent database locking."""
          if connection.vendor == 'sqlite':
              cursor = connection.cursor()
              cursor.execute('PRAGMA journal_mode=WAL;')
              cursor.execute('PRAGMA busy_timeout=5000;')
              cursor.close()
      ```

   d. Add/update LOGGING configuration (before WAL mode section):
      ```python
      # Logging Configuration
      LOGGING = {
          'version': 1,
          'disable_existing_loggers': False,
          'formatters': {
              'verbose': {
                  'format': '{asctime} [{name}] {levelname} {message}',
                  'style': '{',
                  'datefmt': '%H:%M:%S',
              },
          },
          'handlers': {
              'console': {
                  'class': 'logging.StreamHandler',
                  'formatter': 'verbose',
              },
          },
          'loggers': {
              'django-q': {  # NOTE: hyphen, not underscore!
                  'handlers': ['console'],
                  'level': 'DEBUG' if DEBUG else 'INFO',
                  'propagate': False,
              },
          },
      }
      ```

3. Create ___/accounts/tasks.py with test task:
   ```python
   """
   Background tasks for the accounts app.

   Tasks are executed by Django-Q2 qcluster worker process.
   Run worker: python manage.py qcluster
   """
   import logging

   logger = logging.getLogger('django-q')


   def echo_test(message):
       """Simple test task to verify Django-Q2 is working.

       Usage in Django shell:
           from django_q.tasks import async_task
           task_id = async_task('accounts.tasks.echo_test', 'Hello Django-Q2!')
       """
       logger.info(f"Echo task executed: {message}")
       return f"Echo: {message}"
   ```
  </action>
  <verify>
    - `pip list | grep django-q2` shows version 1.9.0
    - `python ___/manage.py check` passes without errors
    - `grep -q "django_q" ___/___/settings.py` returns 0
    - `grep -q "Q_CLUSTER" ___/___/settings.py` returns 0
    - `grep -q "journal_mode=WAL" ___/___/settings.py` returns 0
  </verify>
  <done>
    - Django-Q2 installed and in INSTALLED_APPS
    - Q_CLUSTER configured with timeout=120, retry=180, workers=1, orm='default'
    - WAL mode signal registered
    - Logging configured for django-q
    - Test task function exists
  </done>
</task>

<task type="auto">
  <name>Task 2: Run migrations and verify task execution</name>
  <files>
    - ___/accounts/admin.py
  </files>
  <action>
1. Run Django-Q2 migrations:
   ```bash
   cd ___
   python manage.py migrate django_q
   ```

2. Update ___/accounts/admin.py to add enhanced task monitoring:
   - Add imports at top:
     ```python
     from django_q import models as q_models
     from django_q import admin as q_admin
     ```

   - Add at end of file (after CustomUser admin):
     ```python
     # Django-Q2 Admin Customization
     # Unregister default Failure admin and register enhanced version
     admin.site.unregister([q_models.Failure])

     @admin.register(q_models.Failure)
     class FailureAdmin(q_admin.FailAdmin):
         """Enhanced failed task admin with attempt count and error details."""
         list_display = (
             'name',
             'func',
             'started',
             'stopped',
             'time_taken',
             'attempt_count',
             'short_result',
         )
         list_filter = ('group', 'cluster', 'started')
     ```

3. Verify qcluster starts (INFRA-03):
   ```bash
   cd ___
   # Start qcluster and capture output for 5 seconds, then send SIGINT
   timeout 5 python manage.py qcluster 2>&1 || true
   ```
   Expected: Output showing cluster starting, no errors about missing tables or config

4. Test task execution in a separate verification step:
   - Start qcluster in background (will be killed after test)
   - Queue echo_test task
   - Wait for result
   - Verify task completed successfully

   ```bash
   cd ___
   # Start qcluster in background
   python manage.py qcluster &
   QCLUSTER_PID=$!
   sleep 3

   # Run test task via Django shell
   python manage.py shell -c "
   from django_q.tasks import async_task
   from django_q.models import Task
   import time

   # Queue task
   task_id = async_task('accounts.tasks.echo_test', 'Test message')
   print(f'Task queued: {task_id}')

   # Wait for completion
   time.sleep(5)

   # Check result
   try:
       task = Task.objects.get(id=task_id)
       print(f'Success: {task.success}')
       print(f'Result: {task.result}')
       if task.success and 'Echo: Test message' in str(task.result):
           print('VERIFICATION PASSED')
       else:
           print('VERIFICATION FAILED - task did not succeed')
   except Task.DoesNotExist:
       print('VERIFICATION FAILED - task not found in database')
   "

   # Stop qcluster
   kill $QCLUSTER_PID 2>/dev/null || true
   ```

5. Verify WAL mode is active (INFRA-02):
   ```bash
   cd ___
   python manage.py shell -c "
   from django.db import connection
   cursor = connection.cursor()
   cursor.execute('PRAGMA journal_mode;')
   mode = cursor.fetchone()[0]
   print(f'Journal mode: {mode}')
   if mode.lower() == 'wal':
       print('WAL MODE VERIFIED')
   else:
       print('WARNING: WAL mode not active')
   "
   ```
  </action>
  <verify>
    - `python ___/manage.py showmigrations django_q` shows all migrations applied
    - qcluster starts without "table does not exist" errors
    - Echo task returns "Echo: Test message" in result
    - PRAGMA journal_mode returns "wal"
    - Django admin shows "Django Q2" section with Success, Failure, Schedule, OrmQ models
  </verify>
  <done>
    - Django-Q2 migrations applied (4 tables created)
    - qcluster process starts successfully (INFRA-03)
    - Echo test task executes and completes (success=True)
    - WAL mode confirmed active (INFRA-02)
    - Enhanced Failure admin registered with duration and attempt count columns
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Admin visibility:** Start runserver and visit /admin/ - "Django Q2" section visible with Success, Failure, Schedule, OrmQ links

2. **No database locking:** Run qcluster in one terminal, runserver in another, access admin - no "database is locked" errors

3. **Task execution verified:** Success model contains at least one entry (the echo_test from Task 2)

```bash
cd ___
python manage.py shell -c "
from django_q.models import Task, Success
print(f'Total tasks: {Task.objects.count()}')
print(f'Successful tasks: {Success.objects.count()}')
echo_tasks = Task.objects.filter(func='accounts.tasks.echo_test')
for t in echo_tasks:
    print(f'  - {t.id}: success={t.success}, result={t.result}')
"
```
</verification>

<success_criteria>
- [ ] INFRA-01: Django-Q2 installed with ORM broker (`'orm': 'default'` in Q_CLUSTER)
- [ ] INFRA-02: SQLite WAL mode enabled (PRAGMA journal_mode returns 'wal')
- [ ] INFRA-03: qcluster process runs without errors
- [ ] INFRA-04: Timeout=120s, retry=180s configured in Q_CLUSTER
- [ ] Django admin shows Django Q2 section
- [ ] Echo test task executed successfully (result contains "Echo:")
</success_criteria>

<output>
After completion, create `.planning/phases/11-django-q2-foundation/11-01-SUMMARY.md`
</output>
