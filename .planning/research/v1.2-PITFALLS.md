# Pitfalls Research: v1.2 Referrals

**Domain:** Django referral tracking for authentication portal
**Researched:** 2026-01-19
**Confidence:** MEDIUM (based on Django docs, library patterns, and security best practices)

## Critical Pitfalls

Mistakes that cause data loss, security vulnerabilities, or require significant rewrites.

---

### Pitfall 1: Self-Referential Foreign Key Migration on Existing User Table

**What goes wrong:** Adding a `referred_by` ForeignKey pointing to the same CustomUser model fails migration on existing users, or creates circular dependency issues.

**Why it happens:** When you add a ForeignKey to an existing model that already has rows:
1. Django requires a default value for existing rows
2. `ForeignKey('self')` cannot have a simple default (what user would it point to?)
3. Migrations may crash with KeyError when renaming models with self-referential FK (documented Django bug [#23160](https://code.djangoproject.com/ticket/23160))

**Consequences:**
- Migration fails with "You are trying to add a non-nullable field 'referred_by' to customuser without a default"
- Existing users cannot be migrated
- Database left in inconsistent state
- May require manual SQL fixes

**Prevention:**
Use a three-phase migration strategy:

```python
# Phase 1: Add nullable field (0001_add_referred_by.py)
migrations.AddField(
    model_name='customuser',
    name='referred_by',
    field=models.ForeignKey(
        'self',
        on_delete=models.SET_NULL,
        null=True,  # MUST be nullable initially
        blank=True,
        related_name='referrals'
    ),
)

# Phase 2: Data migration if needed (0002_backfill.py) - optional
# Only needed if you have referral data to import

# Phase 3: Keep nullable - referrals are optional by nature
# DO NOT make non-nullable - users can register without referral
```

**Detection:**
- `makemigrations` asks "Please enter a default value" for the ForeignKey
- Migration fails on `python manage.py migrate`

**Phase to address:** First phase (model changes) - get this right before any other referral work.

---

### Pitfall 2: Deleted Referrer Cascades and Deletes All Referrals

**What goes wrong:** When a user who referred others is deleted, all their referred users are also deleted due to `on_delete=models.CASCADE`.

**Why it happens:** `CASCADE` is often the Django default in tutorials. Developers copy-paste without considering the implications.

**Consequences:**
- Deleting one power-referrer (e.g., 50 referrals) deletes 50 user accounts
- Data loss is silent and immediate
- No recovery possible without backups
- Potentially deletes cascading data (referred users' own referrals, etc.)

**Prevention:**
**ALWAYS use `SET_NULL` for referral relationships:**

```python
class CustomUser(AbstractUser):
    referred_by = models.ForeignKey(
        'self',
        on_delete=models.SET_NULL,  # NOT CASCADE
        null=True,
        blank=True,
        related_name='referrals'
    )
```

**Why SET_NULL:**
- Referral relationship is historical record
- Losing the referrer link is acceptable
- Losing the referred user account is catastrophic
- Referral counts can use `COUNT` with `referred_by__isnull=False` filter

**Alternative - PROTECT:**
```python
on_delete=models.PROTECT  # Prevents deletion if user has referrals
```
This prevents deletion entirely - may be appropriate if referrers should never be deleted.

**Detection:**
- Test by deleting a user who has referrals in Django admin
- Check if referred users still exist after deletion

**Phase to address:** First phase (model design) - cannot be easily changed after data exists.

---

### Pitfall 3: Referral URL Parameter Manipulation / Spoofing

**What goes wrong:** Attackers or users can modify the referral code in the URL to credit referrals to wrong users, or use invalid/guessable codes.

**Why it happens:**
- Sequential integer IDs are easily guessable (`?ref=1`, `?ref=2`, `?ref=3`...)
- No server-side validation of referral code ownership
- Referral code exposed in URL can be shared on coupon sites

**Consequences:**
- Users can claim referrals for accounts they don't own
- Referral fraud inflates counts
- Legitimate referrers lose credit
- If referral rewards are added later, financial loss

**Prevention:**

1. **Use non-guessable tokens (UUID or similar):**

```python
import uuid

class CustomUser(AbstractUser):
    referral_code = models.UUIDField(
        default=uuid.uuid4,
        unique=True,
        editable=False
    )
    # ...
```

Or for human-friendly codes:
```python
# Using shortuuid for shorter, URL-safe codes
import shortuuid

def generate_referral_code():
    return shortuuid.uuid()[:8]  # e.g., "3j7K9mNp"

class CustomUser(AbstractUser):
    referral_code = models.CharField(
        max_length=12,
        unique=True,
        default=generate_referral_code,
        editable=False
    )
```

2. **Validate referral code server-side:**

```python
# views.py
def register_view(request):
    referral_code = request.GET.get('ref', '')
    referrer = None

    if referral_code:
        try:
            referrer = CustomUser.objects.get(referral_code=referral_code)
        except CustomUser.DoesNotExist:
            # Invalid code - log and continue without referrer
            logger.warning(f"Invalid referral code attempted: {referral_code}")
            referrer = None

    # Continue with registration, saving referrer if valid
```

3. **Store referral in session (not just URL):**

```python
# When user lands on registration with ?ref=XYZ
def register_view(request):
    # Capture referral code from URL on first visit
    if 'ref' in request.GET:
        request.session['referral_code'] = request.GET['ref']

    # Use session value for actual registration
    referral_code = request.session.get('referral_code', '')
```

**Detection:**
- Manually test registration with modified/invalid referral codes
- Check if changing `?ref=` parameter changes who gets credit

**Phase to address:** Registration flow phase - validate all referral codes.

---

### Pitfall 4: Self-Referral Not Blocked

**What goes wrong:** Users can generate their own referral link, open an incognito window, and register a second account using their own referral link, getting credit for "referring" themselves.

**Why it happens:**
- System only checks if referral code is valid, not who it belongs to
- No cross-reference between new user's email/cedula and referrer
- No device/IP tracking

**Consequences:**
- Inflated referral counts
- Gaming of referral goals
- If rewards added later, fraudulent payouts
- Legitimate referral metrics become meaningless

**Prevention:**

1. **Block exact self-referral (same cedula):**

```python
# During registration, after form is valid
def register_view(request):
    form = RegistrationForm(request.POST)
    if form.is_valid():
        cedula = form.cleaned_data['cedula']
        referral_code = request.session.get('referral_code', '')

        referrer = None
        if referral_code:
            try:
                referrer = CustomUser.objects.get(referral_code=referral_code)
                # Block self-referral by cedula
                if referrer.cedula == cedula:
                    messages.warning(request, "No puedes referirte a ti mismo.")
                    referrer = None
            except CustomUser.DoesNotExist:
                pass

        user = form.save(commit=False)
        user.referred_by = referrer
        user.save()
```

2. **Track and flag suspicious patterns (advanced):**

```python
# Store IP and device fingerprint for velocity checks
class ReferralHit(models.Model):
    referrer = models.ForeignKey(CustomUser, on_delete=models.CASCADE)
    ip_address = models.GenericIPAddressField()
    timestamp = models.DateTimeField(auto_now_add=True)
    converted = models.BooleanField(default=False)

# Check for multiple signups from same IP
recent_signups = ReferralHit.objects.filter(
    referrer=referrer,
    ip_address=request.META.get('REMOTE_ADDR'),
    timestamp__gte=timezone.now() - timedelta(hours=24)
).count()

if recent_signups > 3:
    logger.warning(f"Suspicious referral activity from IP {ip}")
```

**For v1.2 scope:** Implement basic cedula-based self-referral blocking. Advanced fraud detection can be deferred.

**Detection:**
- Test: Register as User A, copy referral link, register User B with same cedula (should fail validation anyway)
- Test: Register User B with different cedula using User A's link from same browser

**Phase to address:** Registration validation phase.

---

### Pitfall 5: Referral Code Not Generated for Existing Users After Migration

**What goes wrong:** After adding `referral_code` field to CustomUser model, existing users have `NULL` or empty referral codes because the default only applies to new users.

**Why it happens:**
- Field added with `default=uuid.uuid4`
- Django's `default` is only used when creating new records
- Migration doesn't call `default` for existing rows
- Existing users try to share referral link but it's empty/invalid

**Consequences:**
- Existing users cannot participate in referral program
- Broken referral links (empty or NULL codes)
- 500 errors when generating referral URLs for existing users
- Manual backfill required

**Prevention:**
Create a data migration to backfill existing users:

```python
# 0003_backfill_referral_codes.py
from django.db import migrations
import uuid

def backfill_referral_codes(apps, schema_editor):
    CustomUser = apps.get_model('accounts', 'CustomUser')
    for user in CustomUser.objects.filter(referral_code__isnull=True):
        user.referral_code = uuid.uuid4()
        user.save(update_fields=['referral_code'])

def reverse_backfill(apps, schema_editor):
    pass  # No reverse needed

class Migration(migrations.Migration):
    dependencies = [
        ('accounts', '0002_add_referral_code'),
    ]

    operations = [
        migrations.RunPython(backfill_referral_codes, reverse_backfill),
    ]
```

**Detection:**
- Check Django admin for existing users with empty referral_code
- Test referral link generation for user created before migration

**Phase to address:** Migration phase - run immediately after adding field.

---

## Common Mistakes

Mistakes that cause bugs, poor UX, or technical debt (but not data loss).

---

### Mistake 1: Referral Code Lost Between Landing and Registration

**What goes wrong:** User clicks referral link, lands on registration page, but by the time they complete registration the referral code is lost.

**Why it happens:**
- Referral code only in URL parameter
- User navigates away (views login page, forgets password flow, etc.)
- Returns to registration without `?ref=` in URL
- Referrer doesn't get credit

**Consequences:**
- Lost referral attribution
- Frustrated referrers who shared links but don't see conversions
- Inaccurate referral tracking

**Prevention:**
Store referral code in session immediately upon landing:

```python
# middleware.py
class ReferralMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        # Capture referral code from any URL, store in session
        if 'ref' in request.GET and not request.user.is_authenticated:
            request.session['referral_code'] = request.GET['ref']
            request.session.modified = True

        response = self.get_response(request)
        return response
```

**Or use a cookie for persistence across sessions:**

```python
# views.py - when handling referral link
def landing_with_referral(request):
    ref_code = request.GET.get('ref')
    response = redirect('accounts:register')
    if ref_code:
        # Set cookie that persists for 30 days
        response.set_cookie('referral_code', ref_code, max_age=30*24*60*60)
    return response
```

**Detection:**
- Test: Click referral link, navigate to login, go back to register, complete registration
- Check if referral was attributed

**Phase to address:** Registration flow phase.

---

### Mistake 2: Not Handling Referral Code Case Sensitivity

**What goes wrong:** Referral code "ABC123" works but "abc123" doesn't, or vice versa, depending on database collation.

**Why it happens:**
- UUIDs are case-insensitive but stored lowercase
- Custom codes may be generated uppercase but compared case-sensitively
- Database default collation varies (SQLite vs PostgreSQL)

**Consequences:**
- Valid referral codes rejected
- User frustration when manually typing codes
- Inconsistent behavior across environments

**Prevention:**
Normalize case on both storage and lookup:

```python
# models.py - store lowercase
def generate_referral_code():
    return shortuuid.uuid()[:8].lower()

# views.py - lookup case-insensitive
def get_referrer(referral_code):
    return CustomUser.objects.get(
        referral_code__iexact=referral_code.strip()
    )
```

For UUIDs, this is less of an issue as Django's UUIDField handles normalization, but be consistent.

**Detection:**
- Test with different case variations of same code

**Phase to address:** Registration validation phase.

---

### Mistake 3: Referral Count Shows All-Time Instead of Relevant Period

**What goes wrong:** User sees "You have 50 referrals!" but most were from months ago. Current month shows 0 progress toward monthly goal.

**Why it happens:**
- Simple `user.referrals.count()` counts all referrals ever
- No date filtering for goals
- Goals are time-based but counts are all-time

**Consequences:**
- Misleading metrics
- User confusion about goal progress
- Feature appears broken

**Prevention:**
Always specify time period for goal-related counts:

```python
# views.py
from django.utils import timezone
from datetime import timedelta

def home_view(request):
    user = request.user

    # All-time referral count
    total_referrals = user.referrals.count()

    # This month's referrals (for monthly goal)
    start_of_month = timezone.now().replace(day=1, hour=0, minute=0, second=0)
    monthly_referrals = user.referrals.filter(
        date_joined__gte=start_of_month
    ).count()

    # Goal progress
    goal = user.referral_goal or 0
    progress_percent = (monthly_referrals / goal * 100) if goal > 0 else 0

    return render(request, 'home.html', {
        'total_referrals': total_referrals,
        'monthly_referrals': monthly_referrals,
        'goal': goal,
        'progress_percent': min(progress_percent, 100),
    })
```

**Detection:**
- Set a monthly goal of 5
- Check progress display when you have 10 all-time but 0 this month

**Phase to address:** Home page display phase.

---

### Mistake 4: Profile Edit Allows Changing Cedula (Breaks Referral Identity)

**What goes wrong:** User edits profile and changes their cedula, but referral relationships are based on user ID, causing confusion in referidos table.

**Why it happens:**
- Profile edit form includes cedula field
- Cedula is the username/login identifier
- Changing it could break login or create duplicate identity confusion

**Consequences:**
- User can't log in with old cedula
- Confusion about identity in referidos list
- Potential for abuse (change cedula to avoid detection)

**Prevention:**
Make cedula read-only in profile edit:

```python
# forms.py
class ProfileEditForm(forms.ModelForm):
    class Meta:
        model = CustomUser
        fields = ['nombre_completo', 'phone']  # Exclude cedula

    # Or if showing cedula, make it disabled:
    cedula = forms.CharField(disabled=True, required=False)
```

In template:
```html
<div class="mb-3">
    <label class="form-label">Cedula</label>
    <input type="text" class="form-control" value="{{ user.cedula }}" disabled>
    <small class="text-muted">La cedula no puede ser modificada.</small>
</div>
```

**Detection:**
- Try to edit cedula in profile form
- Should be disabled or not present

**Phase to address:** Profile edit phase.

---

### Mistake 5: Referidos Table Missing Pagination

**What goes wrong:** User with 100+ referrals sees a page that loads slowly, crashes browser, or shows all records on one page.

**Why it happens:**
- Simple `user.referrals.all()` returns all records
- No pagination implemented
- No limit on queryset

**Consequences:**
- Slow page loads
- Browser memory issues with large tables
- Poor UX for successful referrers

**Prevention:**
Implement Django pagination:

```python
# views.py
from django.core.paginator import Paginator

def referidos_view(request):
    referral_list = request.user.referrals.order_by('-date_joined')
    paginator = Paginator(referral_list, 25)  # 25 per page

    page_number = request.GET.get('page', 1)
    referrals = paginator.get_page(page_number)

    return render(request, 'referidos.html', {'referrals': referrals})
```

In template:
```html
<nav aria-label="Pagination">
    <ul class="pagination">
        {% if referrals.has_previous %}
        <li class="page-item">
            <a class="page-link" href="?page={{ referrals.previous_page_number }}">Anterior</a>
        </li>
        {% endif %}
        <li class="page-item active">
            <span class="page-link">Pagina {{ referrals.number }} de {{ referrals.paginator.num_pages }}</span>
        </li>
        {% if referrals.has_next %}
        <li class="page-item">
            <a class="page-link" href="?page={{ referrals.next_page_number }}">Siguiente</a>
        </li>
        {% endif %}
    </ul>
</nav>
```

**Detection:**
- Test with many referrals (can seed test data)
- Check page load time and memory

**Phase to address:** Referidos page phase.

---

## Edge Cases

Scenarios that need explicit handling to avoid bugs or confusion.

---

### Edge Case 1: User Clicks Own Referral Link

**Scenario:** Logged-in user clicks their own referral link (from a shared post they made).

**What should happen:** Nothing changes - no error, no redirect loop.

**Prevention:**
```python
# In referral landing view or middleware
if request.user.is_authenticated:
    # Logged-in users don't need referral tracking
    return redirect('accounts:home')
```

---

### Edge Case 2: Referrer Deletes Account While Referral Link is Active

**Scenario:** User A shares referral link. User A deletes account. User B clicks the now-invalid link and tries to register.

**What should happen:** Registration proceeds normally without referral attribution.

**Prevention:**
```python
# Handle deleted referrer gracefully
try:
    referrer = CustomUser.objects.get(referral_code=code)
except CustomUser.DoesNotExist:
    referrer = None
    # Optionally: messages.info(request, "El enlace de referido ya no es valido.")
```

---

### Edge Case 3: User Registers, Then Referrer is Deleted

**Scenario:** User B was referred by User A. Later, User A is deleted. What shows in User B's "referred by" field?

**What should happen:** User B's profile shows "Referido por: (usuario eliminado)" or similar, not an error.

**Prevention:**
```python
# In template
{% if user.referred_by %}
    Referido por: {{ user.referred_by.nombre_completo }}
{% elif user.referred_by is None %}
    Referido por: (usuario eliminado)
{% else %}
    Registro directo
{% endif %}

# Or with model method
class CustomUser(AbstractUser):
    def get_referrer_display(self):
        if self.referred_by:
            return self.referred_by.nombre_completo
        elif self.referred_by_id is not None:  # Was set but now NULL
            return "(usuario eliminado)"
        return "Registro directo"
```

**Note:** This requires understanding the difference between `referred_by=None` (never had a referrer) vs `referred_by_id=None` after SET_NULL (had referrer who was deleted). Both result in `referred_by=None` in Django ORM, so you may need to track this differently if important.

---

### Edge Case 4: Multiple Referral Codes for Same User

**Scenario:** Due to a bug or migration issue, a user ends up with multiple referral codes, or the same code is assigned to multiple users.

**What should happen:** This should be impossible due to unique constraint.

**Prevention:**
```python
referral_code = models.CharField(
    max_length=12,
    unique=True,  # Database-level constraint
    default=generate_referral_code,
)
```

**Post-migration validation:**
```python
# Django management command to verify
from django.core.management.base import BaseCommand
from accounts.models import CustomUser
from django.db.models import Count

class Command(BaseCommand):
    def handle(self, *args, **kwargs):
        # Check for NULL codes
        null_codes = CustomUser.objects.filter(referral_code__isnull=True).count()
        if null_codes:
            self.stdout.write(self.style.WARNING(f'{null_codes} users have NULL referral codes'))

        # Check for duplicates (shouldn't be possible with unique=True)
        duplicates = CustomUser.objects.values('referral_code').annotate(
            count=Count('id')
        ).filter(count__gt=1)
        if duplicates:
            self.stdout.write(self.style.ERROR(f'Duplicate codes found: {list(duplicates)}'))
```

---

### Edge Case 5: Referral Goal Set to Zero

**Scenario:** User sets referral goal to 0 (or leaves it empty).

**What should happen:** Progress bar shows 100% or is hidden, division by zero is avoided.

**Prevention:**
```python
# In view
goal = user.referral_goal or 0
if goal > 0:
    progress_percent = min((monthly_referrals / goal) * 100, 100)
else:
    progress_percent = 0  # Or 100 if "no goal" means "always complete"

# In template
{% if goal > 0 %}
    <div class="progress">
        <div class="progress-bar" style="width: {{ progress_percent }}%">
            {{ monthly_referrals }}/{{ goal }}
        </div>
    </div>
{% else %}
    <p class="text-muted">Establece una meta en tu perfil.</p>
{% endif %}
```

---

### Edge Case 6: Unicode/Special Characters in Referral URL

**Scenario:** Referral code or URL is copy-pasted with invisible characters, smart quotes, or URL-encoded incorrectly.

**What should happen:** Code is normalized and matched correctly.

**Prevention:**
```python
# Strip and normalize
referral_code = request.GET.get('ref', '').strip()
# Remove common copy-paste artifacts
referral_code = referral_code.replace('\u200b', '')  # Zero-width space
referral_code = referral_code.replace('\ufeff', '')  # BOM
```

---

## Prevention Summary

| Pitfall | Prevention | Phase |
|---------|------------|-------|
| Self-referential FK migration fails | Add field with `null=True` first, never make non-nullable | Model design |
| CASCADE deletes referred users | Use `on_delete=models.SET_NULL` | Model design |
| Referral URL manipulation | Use UUID or non-guessable codes, validate server-side | Model + Registration |
| Self-referral fraud | Check cedula match before saving | Registration validation |
| Existing users have no referral code | Data migration to backfill codes | Migration |
| Referral code lost during navigation | Store in session/cookie on first visit | Registration flow |
| Case sensitivity issues | Use `__iexact` lookup, normalize storage | Registration validation |
| Wrong time period for goal counts | Filter by date_joined for period-specific counts | Home page display |
| Cedula editable in profile | Exclude or disable cedula field | Profile edit |
| No pagination on referidos | Implement Django Paginator | Referidos page |
| Logged-in user clicks own link | Skip referral tracking for authenticated users | Referral landing |
| Deleted referrer's link used | Handle DoesNotExist gracefully | Registration |
| Division by zero on goal | Check goal > 0 before calculating percent | Home page display |

---

## Phase Recommendations

Based on pitfall severity and dependencies:

**Phase 1: Model Design** (Critical - do first)
- Add `referred_by` with `null=True`, `on_delete=SET_NULL`
- Add `referral_code` with UUID default, `unique=True`
- Add `referral_goal` with `null=True` or `default=0`
- Create data migration for existing users

**Phase 2: Registration Flow** (Security-critical)
- Capture referral code in session/cookie
- Validate referral code exists
- Block self-referral by cedula
- Handle invalid/expired codes gracefully

**Phase 3: Home Page Display** (User-facing)
- Calculate time-period-specific counts
- Handle zero goal without division error
- Show shareable referral link

**Phase 4: Profile Edit** (User-facing)
- Disable cedula field
- Allow goal setting with validation

**Phase 5: Referidos Page** (User-facing)
- Implement pagination
- Handle deleted referrer display

---

## Sources

**Django ForeignKey and Migrations:**
- [Django on_delete Options - Sentry](https://sentry.io/answers/django-on-delete/) - HIGH confidence
- [Foreign Keys On_Delete Option - GeeksforGeeks](https://www.geeksforgeeks.org/python/foreign-keys-on_delete-option-in-django-models/) - MEDIUM confidence
- [Django Ticket #23160 - Self-referential FK KeyError](https://code.djangoproject.com/ticket/23160) - HIGH confidence
- [Django ORM Cookbook - Self-referencing FK](https://books.agiliq.com/projects/django-orm-cookbook/en/latest/self_fk.html) - MEDIUM confidence

**Referral Fraud Prevention:**
- [Referral Abuse Types and Prevention - Unit21](https://www.unit21.ai/trust-safety-dictionary/referral-fraud) - MEDIUM confidence
- [Self-Referral Fraud Detection - Rewardful](https://www.rewardful.com/articles/self-referral-fraud-detection-for-saas-founders) - MEDIUM confidence
- [Referral Fraud Prevention - SEON](https://seon.io/resources/referral-fraud/) - MEDIUM confidence
- [How to Prevent Referral Fraud - GrowSurf](https://growsurf.com/blog/referral-fraud) - MEDIUM confidence

**URL Security:**
- [Web Parameter Tampering - OWASP](https://owasp.org/www-community/attacks/Web_Parameter_Tampering) - HIGH confidence
- [Information Exposure Through Query Strings - OWASP](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url) - HIGH confidence

**Django Referral Libraries (patterns reference):**
- [django-reflinks - GitHub](https://github.com/HearthSim/django-reflinks) - MEDIUM confidence
- [pinax-referrals - GitHub](https://github.com/pinax/pinax-referrals) - MEDIUM confidence
- [django-referral-system Documentation](https://django-referral-system.readthedocs.io/en/latest/) - MEDIUM confidence

**UUID and Token Generation:**
- [UUID as Primary Key in Django - GeeksforGeeks](https://www.geeksforgeeks.org/python/using-uuid-as-the-primary-key-in-django-models/) - MEDIUM confidence
- [Unique Obfuscated URLs in Django - alldjango](https://alldjango.com/tips/unique-obfuscated-urls-django) - LOW confidence
- [Django Ticket #32276 - UUID Migration Issues](https://code.djangoproject.com/ticket/32276) - HIGH confidence

**Session and Cookie Handling:**
- [Django Sessions Framework - MDN](https://developer.mozilla.org/en-US/docs/Learn/Server-side/Django/Sessions) - HIGH confidence
- [Anonymous User Sessions in Django - Medium](https://medium.com/@sunilnepali844/handling-anonymous-user-sessions-in-django-a-complete-guide-78fb563a28b2) - LOW confidence
